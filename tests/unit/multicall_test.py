import pytest
from test.mock import MagicMock
from web3 import Web3, HTTPProvider
from src.lib.utils.multi_call import MultiCaller  # Import from your project structure
from src.lib.data_entities.networks import get_l2_network  # Import from your project structure
from web3 import EthereumTesterProvider
from web3 import Web3, EthereumTesterProvider
from eth_tester import EthereumTester
from eth_tester.exceptions import TransactionFailed
from eth_tester import EthereumTester, PyEVMBackend
from eth_tester.backends.pyevm.main import get_default_account_keys
from unittest.mock import Mock, call

# Replace 'your_project' with the actual name of your project module

@pytest.fixture
async def provider_mock():
    # eth_tester = EthereumTester()
    # provider = EthereumTesterProvider(eth_tester)
    # web3 = Web3(provider)
    
    l2_network = get_l2_network(42161)
    l2_provider_mock = MagicMock(spec=HTTPProvider)
    latest_block = l2_network.nitro_genesis_block + 1000
    l2_provider_mock.eth.getBlockNumber = MagicMock(return_value=latest_block)
    l2_provider_mock.eth.getNetwork = MagicMock(return_value={'chainId': l2_network['chainID']})
    l2_provider_mock.eth.getLogs = MagicMock(return_value=[])

    l2ProviderMock = Mock()


    # # Set up the blockchain state
    # latest_block = l2_network.nitro_genesis_block + 1000
    # print(eth_tester.get_block_by_number('latest'))
    # block_ts = eth_tester.get_block_by_number(latest_block)['timestamp']
    # eth_tester.time_travel(block_ts)

    # # Create a mock provider
    # mock_provider = MagicMock(spec=Web3(provider))

    # Mocking the call method for specific scenarios
    # Mock response for Maker
    maker_call = {
        'data': '0xbce38bd7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000009f8f72aa9304c8b593d555f12ef6589cc3a579a20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000406fdde03000000000000000000000000000000000000000000000000000000000000000000000000000000009f8f72aa9304c8b593d555f12ef6589cc3a579a20000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000495d89b4100000000000000000000000000000000000000000000000000000000',
        'to': '0x108B25170319f38DbED14cA9716C54E5D1FF4623',
    }
    maker_response = '0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000204d616b65720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000204d4b520000000000000000000000000000000000000000000000000000000000'  # Replace with actual mock response for Maker

    # Mock response for Uniswap
    uniswap_call = {
        'data': '0xbce38bd7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000406fdde03000000000000000000000000000000000000000000000000000000000000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000495d89b4100000000000000000000000000000000000000000000000000000000',  
        'to': '0x108B25170319f38DbED14cA9716C54E5D1FF4623',
    }
    uniswap_response = '0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000007556e69737761700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003554e490000000000000000000000000000000000000000000000000000000000' 
    
    # Configure side effects for the mock call method
    def side_effect(call, block_identifier):
        if call == maker_call:
            return maker_response
        elif call == uniswap_call:
            return uniswap_response
        return None

    mock_provider.eth.call.side_effect = side_effect

    return mock_provider

@pytest.mark.asyncio
async def test_returns_parsed_data_from_bytes32(provider_mock):
    mock_provider = await provider_mock
    multicaller = await MultiCaller.from_provider(mock_provider)
    data = await multicaller.get_token_data(['0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2'], {'symbol': True, 'name': True})

    assert data['name'] == 'Maker', 'Failed to get token name from bytes32'
    assert data['symbol'] == 'MKR', 'Failed to get token symbol from bytes32'

# @pytest.mark.asyncio
# async def test_returns_parsed_data_from_byte_string(provider_mock):
#     multicaller = await MultiCaller.from_provider(provider_mock)
#     data = await multicaller.get_token_data(['0x1f9840a85d5af5bf1d1762f925bdaddc4201f984'], {'symbol': True, 'name': True})

#     assert data['name'] == 'Uniswap', 'Failed to get token name from byte string'
#     assert data['symbol'] == 'UNI', 'Failed to get token symbol from byte string'
